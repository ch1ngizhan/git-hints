# git-hints

# Хеш — идентификатор коммита
В процессе работы с Git вам будет часто встречаться понятие «хеш коммита».
Эти странные строчки с бессмысленным (на первый взгляд) набором букв и цифр вы могли видеть,
когда вызывали команду```git log```и выводили историю коммитов.

Хеширование (от англ. hash, «рубить», «крошить», «мешанина»)
— это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).

В то время, как результат работы метода hashCode() — это целое число, результат хеширования в Git — символьная строка. Она относительно коротка (
40 символов в случае SHA-1) и состоит из цифр
0—9 и латинских букв
A—F (неважно, заглавных или строчных). Хеш обладает следующими важными свойствами:

-если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;

-если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Git хранит таблицу соответствий ```хеш → информация о коммите```. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что ```хеш — основной идентификатор коммита```.
При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
Все хеши и таблицу```хеш → информация о коммите``` Git сохраняет в служебные файлы. Они находятся в скрытой папке ```.git``` в репозитории проекта.

# Исследуем лог
После вызова ```git log``` появляется список коммитов с их описанием.

Вот из каких элементов состоит описание:

1.Строка из цифр и латинских букв после слова commit — это уже знакомый вам хеш коммита.

2.Author — имя автора и его электронная почта.

3.Date — дата и время создания коммита.

4.Сообщение к коммиту.

Сокращённый хеш (первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда ```git log --oneline``` автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

# ```HEAD``` — всему голова
При вызове команды ```git log``` вы также могли заметить надпись ```(HEAD -> master)``` после хеша одного из коммитов.

Файл ```HEAD``` (англ. «голова», «головной») — один из служебных файлов папки``` .git```. Он указывает на коммит, который сделан последним (то есть на самый новый).
Убедитесь в этом с помощью терминала. Перейдите в папку ```.git ```командой ```cd```. Посмотрите содержимое файла HEAD командой ```cat```.

````
$ pwd # посмотрели, где мы
/Users/user/dev/first-project

$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка
````
Внутри`` HEAD`` — ссылка на служебный файл: ``refs/heads/master`` (или ``refs/heads/main`` в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.
````
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты
````
Когда вы делаете коммит, Git обновляет ``refs/heads/master`` — записывает в него хеш последнего коммита. Получается, что ``HEAD`` тоже обновляется, так как ссылается на ``refs/heads/master``.

При работе с Git указатель`` HEAD`` используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово`` HEAD — Git`` поймёт, что вы имели в виду последний коммит.


# Статусы ```untracked/tracked```, ```staged``` и ```modified```
Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.
untracked (англ. «неотслеживаемый»)

Новые файлы в Git-репозитории помечаются как ``untracked``, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду ``git add``.
``staged`` (англ. «подготовленный»)

После выполнения команды ```git add``` файл попадает в ``staging area`` (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии ``staged``.

``tracked`` (англ. «отслеживаемый»)

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
modified (англ. «изменённый»)

Состояние modified значит, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.